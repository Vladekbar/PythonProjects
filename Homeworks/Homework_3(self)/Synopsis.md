### О МЕТОДЕ  .count()

.count() - это метод, внутри которого реализуется алгоритм подсчета.

Алгоритм может быть представлен в виде функции:
```python
def custom_count(sequence, item):
    count = 0
    for element in sequence:
        if element == item:
            count += 1
    return count
```

### Операции со множествами

```python
a = {1, 2, 3, 5, 8}
b = {2, 5, 8, 13, 21}
c = a.copy()
print(c)
u = a.union(b) # объединение повторяющихся значений + запись неповторяющихся
print(u) # {1, 2, 3, 5, 8, 13, 21}
i = a.intersection(b) # Пересечение, т. е.повторение повторяющихся значений
print(i) # {8, 2, 5}
dl = a.difference(b) # Из множества a вычитаем повторяемые элементы множествa b
print(dl) # {1, 3}
dr = b.difference(a)
print(dr) # {13, 21}
q = a.union(b).difference(a.intersection(b)) # порядок опишем ниже
print(q) # {1, 21, 3, 13}
```
*Порядок выполнения*
1) a.intersection(b) # {2, 5, 8}
2) a.union(b) # {1, 2, 3, 5, 8, 13, 21}
3) {1, 2, 3, 5, 8, 13, 21}  difference  {2, 5, 8} = {1, 3, 13, 21}

### Интересный пример

Требуется найти в массиве list_1 самый близкий по величине элемент к заданному числу k и вывести его.

```python
list_1 = [1, 2, 3, 4, 5]
k = 6 
```
Рассмотрим не менее интересное решение:

```python
new_list = [abs(list_1[i]-k) for i in range(len(list_1))]
print(list_1[new_list.index(min(new_list))])
```

При создании нового списка в квадратных скобках указан оператор for,
который обычно стоит где-то в начале, а в конце условия содержится двоеточие.

В данном контексте for выполняет итерацию по индексам элементов списка list_1.

*for* используется в генераторе списка, который создает новый список *new_list*. 
Генератор списка - это синтаксический сахар, который позволяет создавать новый список путем выполнения итерации 
по другому итерируемому объекту.В данном случае, по *range(len(list_1)))* и применения выражения 
(в данном случае, *abs(list_1[i]-k))* к каждому элементу.

Разберем по порядку на примерах.

1) Создание списка из генерируемых элементов:
```python
list_1 = [i for i in range(5)]
print(list_1)
```
>[0, 1, 2, 3, 4]

2) Заранее зададим условие, чтобы элементы видоизменялись по ходу итеррации.
```python
list_1 = [i+2 for i in range(5)]
print(list_1)
```
>[2, 3, 4, 5, 6]

Уже результат отличается.

5) А давайте добавим туда модуль, а сложение заменим вычитанием?
```python
list_1 = [abs(i-2) for i in range(5)]
print(list_1)
```
>[2, 1, 0, 1, 2]

Очень интересно! (И все понятно, не надо тут.)

Вернемся ко второй строке нашего кода.
```python
print(list_1[new_list.index(min(new_list))])
```
В общих черта понятно, что требуется вывести некий элемент.
```python
print(list_1['нечто страшное'])
```
Разберем 'нечто страшное'.
```python
new_list.index(min(new_list))
```
>min(new_list)

функция min вернет наименьшее значение элемента в списке.

>new_list.index(min(new_list))  

укажет индекс наименьшего элемента. 

Соответсвенно:


```python
print(list_1['укажет индекс наименьшего элемента'])
```

#### Выведет сам элемент.

### Чисто пример для упрощения понимания.

```python
l_1 = [i for i in range(1,6)]
print(l_1) # [1, 2, 3, 4, 5] # Вывод списка
print(min(l_1)) # 1 Вывод минимального элемента
print(l_1.index(max(l_1))) # 4 Вывод ИНДЕКСА максимального элемента
print(l_1[(l_1.index(max(l_1)))]) # 5 Вывод МАКСИМАЛЬНОГО элемента.

```