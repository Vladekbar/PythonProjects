### В поисках просто задачи.
<p align="justify">
Координаторы Codeforces выбирают задачу для очередного чемпионата, стремясь сделать ее максимально простой.
Они опрашивают n человек и принимают решение о замене задачи в случае, если хотя бы один человек считает ее сложной.
Определите, нужно ли заменить задачу, основываясь на ответах опрошенных.
Выведите одно слово: «EASY», если задача по мнению всех опрошенных является легкой, либо «HARD»,
если хотя бы один опрошенный считает задачу сложной.
</p>

* Пример:
* входные данные
```
3
0 0 1
```
* выходные данные
``` 
HARD
```
#### Решение 1. Генератор списка.
```python
n = int(input('Сколько людей голосуют?: '))
data = [int(input('Задача трудная? Если да - введите "1", если нет - введите "0": ')) for i in range(n)]
if sum(data) == 0:
    print('EASY')
else:
    print('HARD')
```
Сокращенный код:
```python
data = [int(input('')) for i in range(int(input()))]

if sum(data) == 0:
    print('EASY')
else:
    print('HARD')
```
<p align="justify">
Здесь мы заморочились немного, с расчетом на возникновение вопроса о том, зачем вообще нужно количество людей указывать при ввооде? В первом случае (как полный, так и сокращенный), значение n служит нам для создания списка, за границы которого мы не выходим, таким образом, голосуют все.
Если строго следовать условиям, можно переписать код иначе:
</p>

```python
n = int(input(''))
data = list(map(int, input().split()))
if sum(data) == 0:
    print('EASY')
else:
    print('HARD')
# Вход будет выглядеть, как в образце.
# 3
# 0 0 1
```
Заодно вспомнили один из способов создания списка:

```data = list(различные операции)```

#### Решение 2. Через булевое значение.
Немного повторения:
```commandline
>>> a = 5
>>> b = 6
>>> b > a
True
>>> b < a
False
```
В числовом представлении значение True и False имеют числовое значение:
```commandline
>>> a = 5
>>> b = 6
>>> int(b > a)
1
>>> int(b < a)
0
```
А значит, мы можем совершать с данными значениями различные арифмитеческие операции. Int можно опустить, питон автоматические возвращает булевому значению аналогичное int-овое:
```commandline
>>> a = 5
>>> b = 6
>>> int(b > a) + 2
3
>>> int(b < a) * 3
0
```
Вспомним, что строки также можно складывать и умножать на int-овые значения:
```commandline
>>> a = 'privet, '
>>> b = 'drug!'
>>> a + b
'privet, drug!'
>>> a * 1
'privet, '
>>> a * 2
'privet, privet, '
>>> a * 2 + b *0
'privet, privet, '
>>> a*2 + b * (1<0) # Комментарий: (1<0) это False, вернет 0
'privet, privet, '
```
**Так а зачем тут это? Мы же со списком работаем...**
А вот зачем. Используем что-то наподобие данной операции:
```commandline
>>> a * 2 + b *0
'privet, privet, '
>>> a*2 + b * (1<0) 
```
Пример использования булевого значение в нашей задаче:
```python
n = int(input())
s = list(map(int, input().split()))
print('EASY' * (sum(s) == 0) + 'HARD' * (sum(s) > 0))
```
А можно и так:
```python
n=int(input())
x = list(map(int,input().split()))
print((max(x)>=1)*'Hard' or (max(x)<1)*'Easy')
```
*Не стоит вообще забывать, что внутри функции ```print``` может умещаться целая программа. ```print``` - это не просто "инструмент" для конечного вывода результата.